import io
from re import template
from normalizer import docker
from pathlib import Path
from posixpath import basename
from textwrap import dedent
from typing import Dict, List

from dockerfile_parse import DockerfileParser


class ExecutorDockerfile:
    def __init__(
        self, docker_file: 'Path' = None, build_args: Dict = {'JINA_VERSION': 'master'}
    ):
        self._buffer = io.BytesIO()
        if (docker_file is not None) and docker_file.exists():
            self._buffer.write(docker_file.open('rb').read())
            self._parser = DockerfileParser(
                fileobj=self._buffer, env_replace=True, build_args=build_args
            )
        else:

            self._parser = DockerfileParser(
                fileobj=self._buffer, env_replace=True, build_args=build_args
            )

            dockerfile_template = dedent(
                """\
                # This file is automatically generated by Jina executor normalizer plugin.
                # It is not intended for manual editing.

                FROM jinaai/jina:{0}

                ARG JINA_VERSION

                # # install the third-party requirements
                # RUN apt-get update && apt-get install --no-install-recommends -y gcc build-essential git \
                #     && rm -rf /var/lib/apt/lists/*

                # # setup the workspace
                # COPY . /workspace
                # WORKDIR /workspace

                """
            )

            self._parser.content = dockerfile_template.format(
                build_args['JINA_VERSION']
            )

    def __str__(self):
        return self.content

    def add_apt_installs(self, tools):
        instruction_template = dedent(
            """\
            # install the third-party requirements
            RUN apt-get update && apt-get install --no-install-recommends -y {0} \
                && rm -rf /var/lib/apt/lists/*

            """
        )
        instruction = instruction_template.format(' '.join(tools))
        self._parser.content += isinstance

    def add_work_dir(self, tools):
        instruction_template = dedent(
            """\
            # install the third-party requirements
            RUN apt-get update && apt-get install --no-install-recommends -y {0} \
                && rm -rf /var/lib/apt/lists/*

            """
        )
        instruction = instruction_template.format(' '.join(tools))
        self._parser.content += isinstance

    def add_unitest(self):
        self._parser.content += dedent(
            """\
            # setup the workspace
            COPY . /workspace
            WORKDIR /workspace
            """
        )

    def add_pip_install(self):
        self._parser.content += dedent(
            """\
            # install the third-party requirements
            RUN pip install -r requirements.txt

            """
        )

    @property
    def parent_images(self):
        return self._parser.parent_images

    @property
    def content(self):
        return self._parser.content

    @property
    def lines(self):
        return self._parser.lines

    @property
    def baseimage(self):
        return self._parser.baseimage

    @baseimage.setter
    def baseimage(self, value: str):
        self._parser.baseimage = value

    @property
    def entrypoint(self):
        """
        Determine the final ENTRYPOINT instruction, if any, in the final build stage.
        ENTRYPOINTs from earlier stages are ignored.
        :return: value of final stage ENTRYPOINT
        """
        value = None
        for insndesc in self._parser.structure:
            if insndesc['instruction'] == 'FROM':  # new stage, reset
                value = None
            elif insndesc['instruction'].upper() == 'ENTRYPOINT':
                value = insndesc['value'].strip()
        return value

    @entrypoint.setter
    def entrypoint(self, values: List[str]):
        """
        setter for final 'entrypoint' instruction in final build stage
        """
        cmd = None
        for insndesc in self._parser.structure:
            if insndesc['instruction'] == 'FROM':  # new stage, reset
                cmd = None
            elif insndesc['instruction'].upper() == 'ENTRYPOINT':
                cmd = insndesc

        new_cmd = 'ENTRYPOINT ' + '[' + ', '.join([f'"{_}"' for _ in values]) + ']'
        if cmd:
            self._parser.add_lines_at(cmd, new_cmd, replace=True)
        else:
            self._parser.add_lines(new_cmd)

    # @property
    # def entrypoint(self):
    #     return self._entrypoint

    # @entrypoint.setter
    # def entrypoint(self, commands: List[str]):
    #     self._entrypoint = commands
    #     command_line = ', '.join([f'"{c}"' for c in commands])

    #     entrypoint_line = f'ENTRYPOINT [{command_line}]'

    #     if self._parser.lines[-1].startswith('ENTRYPOINT'):
    #         self._parser.content = ''.join(self.lines[:-1] + [entrypoint_line])
    #     else:
    #         self._parser.content += entrypoint_line

    def dumps(self):
        return self._buffer.getvalue().decode()

    def dump(self, dockerfile: str):
        with open(dockerfile, 'wb') as fp:
            fp.write(self._buffer.getvalue())
